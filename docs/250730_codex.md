# Implementation Codex

**Date:** 25/07/30

This document summarizes the high‑level design items from **PRD.md**, the current implementation status in the Python source files, and highlights important components that are already implemented (architectures/packages) as well as gaps or unimplemented sections.

---

## 1. Design Items from PRD.md

Below are the key classes, functions, and data structures defined in `PRD.md`:

- **Clock**: global system clock, adjustable and resettable; tracks `systemtime`.
- **AddressManager**: tracks per-address erase/PGM/read states; manages `addrstates`, `addrErasable`, `addrPGMable`, `addrReadable`, and boolean flags.
- **StateSeq**: represents a sequence of states and their durations; supports deduplication, concatenation (`+`), repetition (`*`), slicing, and hashing-based identity.
- **StateTable**: registers `StateSeq` objects and provides current or future state query at a given time.
- **Operation**: atomic NAND operation bound to a `StateSeq`; supports deduplication and identity via `(name, stateseq)`.
- **OperSeq**: sequence of `Operation` instances.
- **OperManager**: manages scheduling table (`optable`) for operations over time.
- **HostReq & HostReqGen**: generates host-level requests, with id, time, args influenced by address and clock state.
- **HostReqInterpreter**: converts `HostReq` to `OperSeq` based on rules from `req_to_operseq.yaml`.
- **NANDScheduler**: orchestrates when and where operations are added to state tables, based on priorities, current NAND state, and clock time.
- **StateOperWeight**, **TimeSpec**, **ExecTime**: configuration dictionaries defining scheduling weights, per-state durations, and execution times (loaded from YAML files).
- **Test Flow**: detailed initialization and runtime loop steps (initializing specs, generating requests, interpreting to operations, scheduling, logging).

---

## 2. External Libraries & Frameworks (Similar Functionality)

The following well-known projects and packages provide related features to this NAND state/operation scheduler and may serve as references or leverage points:

- **SimPy** (Python): a process-based discrete-event simulation framework. Useful for modeling clock-driven state transitions and event scheduling.
- **OMNeT++ / INET** (C++): modular, component-based simulation library, often used for network and system simulations with state machines and schedulers.
- **SystemC** (C++): hardware description and simulation language supporting event-driven simulation, clocks, and finite state machines.
- **DiskSim** / **FlashSim** / **SimpleSSD**: storage system simulators specialized in HDD/SSD/flash with command scheduling, latency modeling, and state management.
- **NVSim** (C++): architectural-level performance, energy, and area modeling tool for non-volatile memory technologies.
- **transitions** (Python): lightweight, object-oriented state machine library. Can define states, events, and transitions declaratively.
- **APScheduler** (Python): in-process task scheduler for cron-like and interval-based job scheduling (less for state machines but relevant to timed operations).
- **Simulus** (Python): another discrete-event simulation package supporting stateful components and timing semantics.
- **AutomataLib** (Java): provides automata and graph-based state machine constructs with tooling and algorithms.

These frameworks cover discrete-event simulation, state machines, and domain-specific storage simulators, overlapping with our PRD concepts of clock-driven state sequences, scheduling operations across resources, and probabilistic/event-based behaviors.

---

## 3. Gaps & Unimplemented Sections

The following critical sections are declared in PRD.md or stubbed in code but not yet implemented:

| Component / Method                   | Location                     | Notes |
|--------------------------------------|------------------------------|-------|
| `OperManager` constructor/methods    | `gen_seq.py: OperManager`    | Stubbed with `pass`; optable management missing |
| `HostReqGen.__init__` & `.create`    | `gen_seq.py: HostReqGen`     | Stubbed; needs host request rules from `host_req.yaml` |
| `HostReqInterpreter`                 | `gen_seq.py: HostReqInterpreter` | Stubbed; needs mapping logic from `req_to_operseq.yaml` |
| `StateMapper.apply_prefix`           | `gen_seq.py: StateMapper`    | Method body missing |
| `AddressManager.update`              | `gen_seq.py: AddressManager` | Stubbed; required for addrErasable/PGMable/readable flags |
| `StateOperWeight` loading            | `main.py`                    | Not loaded; PRD.md specifies `config.yaml` or separate file |
| `host_req.yaml`, `req_to_operseq.yaml` | Project root                | Not present or not loaded as per PRD.md |

---

## 4. Minor Implementation Observations

- **Typo in `StateSeq`**: attribute `self.legnth` should be `self.length` in `__post_init__`.
- **`np.concat` used** in `StateSeq.__add__` instead of `np.concatenate`.

---

## 5. Next Steps / To Do
- Implement `OperManager` to register and manage operation sequences (`optable`).
- Complete `HostReqGen` and `HostReqInterpreter` according to `host_req.yaml` and `req_to_operseq.yaml` specifications.
- Fill in `StateMapper.apply_prefix` logic and integrate it into scheduler or operation pipeline.
- Implement `AddressManager.update` to maintain `addrErasable`, `addrPGMable`, and `addrReadable` arrays and flags.
- Add loading for `StateOperWeight` config and integrate probabilistic scheduling.
- Write unit tests for each major component to validate behavior against PRD specifications.
---
## 6. External Frameworks: 설치 및 사용 예시

아래는 2절에서 언급한 주요 프레임워크·라이브러리별로

1. **언어/실행환경**
2. **설치 방법**
3. **핵심 사용 방식(예제 수준)**

### 6.1 SimPy
- **언어**: 순수 Python
- **설치**:
  ```bash
  pip install simpy
  ```
- **예제**:
  ```python
  import simpy

  def nand_process(env):
      while True:
          print(f"{env.now}: erase start")
          yield env.timeout(5)
          print(f"{env.now}: erase done")
          yield env.timeout(1)

  env = simpy.Environment()
  env.process(nand_process(env))
  env.run(until=20)
  ```

### 6.2 OMNeT++ / INET
- **언어**: C++ (NED DSL)
- **설치**: 공식 홈페이지에서 설치 후 `opp_makemake`, `make`, 실행 파일 실행
- **예제**:
  ```ned
  simple NANDController {
    gates: in in, out out;
  }
  ```
  ```cpp
  void NANDController::handleMessage(cMessage *msg) {
      scheduleAt(simTime() + par("eraseTime").doubleValue(), new cMessage("eraseDone"));
  }
  ```

### 6.3 SystemC
- **언어**: C++
- **설치**: GitHub 소스 빌드(`./configure`, `make`, `make install`)
- **예제**:
  ```cpp
  SC_MODULE(NAND) {
      SC_CTOR(NAND) { SC_THREAD(process); sensitive << clk.pos(); }
      void process() {
          while (true) {
              wait();  // clock rising edge
          }
      }
  };
  ```

### 6.4 DiskSim / FlashSim / SimpleSSD
- **언어**: C (DiskSim), C++ (FlashSim, SimpleSSD)
- **설치**: 소스 다운로드 후 `make`
- **사용**: 구성 파일과 트레이스 입력 → 배치 실행 → 로그/통계 출력

### 6.5 NVSim
- **언어**: C++
- **설치**: `cmake`, `make`
- **사용**: XML/JSON 설정 파일로 메모리·타이밍 정의 → `./nvsim --config configs/xxx.xml`

### 6.6 transitions
- **언어**: Python
- **설치**:
  ```bash
  pip install transitions
  ```
- **예제**:
  ```python
  from transitions import Machine

  class NAND:
      pass

  states = ['idle', 'erasing', 'programming']
  transitions = [
      {'trigger': 'erase', 'source': 'idle', 'dest': 'erasing'},
      {'trigger': 'done',  'source': 'erasing', 'dest': 'idle'}
  ]

  nand = NAND()
  machine = Machine(nand, states=states, transitions=transitions, initial='idle')
  nand.erase()
  print(nand.state)  # erasing
  nand.done()
  print(nand.state)  # idle
  ```

### 6.7 APScheduler
- **언어**: Python
- **설치**:
  ```bash
  pip install apscheduler
  ```
- **예제**:
  ```python
  from apscheduler.schedulers.background import BackgroundScheduler

  def job():
      print("Operation scheduled")

  sched = BackgroundScheduler()
  sched.add_job(job, 'interval', seconds=5)
  sched.start()
  ```

### 6.8 Simulus
- **언어**: Python
- **설치**:
  ```bash
  pip install simulus
  ```
- **예제**:
  ```python
  import simulus

  sim = simulus.simulator()

  @sim.process
  def nand_proc():
      yield sim.hold(3)
      print(f"{sim.now()} erase done")

  sim.run(10)
  ```

### 6.9 AutomataLib
- **언어**: Java
- **설치**: Maven/Gradle 의존성 설정
  ```xml
  <dependency>
    <groupId>de.learnlib</groupId>
    <artifactId>automatalib-core</artifactId>
    <version>0.10.0</version>
  </dependency>
  ```
- **예제**:
  ```java
  AutomatonBuilder<String, Character> builder = AutomatonBuilders
      .newDFA(Character.class)
      .withInitial("idle")
      .from("idle").on('e').to("erasing")
      ...;
  ```

이들 중 **Python** 패키지는 `pip install <패키지명>` 으로 바로 이용 가능하며, 나머지는 C/C++(또는 Java) 기반 소스 빌드 후 구성 파일·API 호출을 통해 시뮬레이션 또는 상태 머신 모델링에 활용하실 수 있습니다.
